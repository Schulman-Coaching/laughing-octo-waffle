name: AWS Infrastructure Setup

on:
  workflow_dispatch:
    inputs:
      project_name:
        description: 'Project name for AWS resources'
        required: true
        type: string
      environment:
        description: 'Environment (dev, staging, prod)'
        required: true
        type: choice
        options:
          - dev
          - staging
          - prod
      aws_region:
        description: 'AWS Region'
        required: true
        type: string
        default: 'us-east-1'

permissions:
  id-token: write
  contents: read

jobs:
  setup-infrastructure:
    name: Setup Basic AWS Infrastructure
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout
        uses: actions/checkout@v6
      
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ inputs.aws_region }}
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0
      
      - name: Create Terraform Configuration
        run: |
          mkdir -p terraform
          cat > terraform/main.tf << 'EOF'
          terraform {
            required_providers {
              aws = {
                source  = "hashicorp/aws"
                version = "~> 5.0"
              }
            }
            backend "s3" {
              bucket = "${{ inputs.project_name }}-terraform-state"
              key    = "${{ inputs.environment }}/terraform.tfstate"
              region = "${{ inputs.aws_region }}"
            }
          }

          provider "aws" {
            region = "${{ inputs.aws_region }}"
            default_tags {
              tags = {
                Project     = "${{ inputs.project_name }}"
                Environment = "${{ inputs.environment }}"
                ManagedBy   = "Terraform"
              }
            }
          }

          # VPC
          resource "aws_vpc" "main" {
            cidr_block           = "10.0.0.0/16"
            enable_dns_hostnames = true
            enable_dns_support   = true
            
            tags = {
              Name = "${{ inputs.project_name }}-${{ inputs.environment }}-vpc"
            }
          }

          # Public Subnets
          resource "aws_subnet" "public" {
            count                   = 2
            vpc_id                  = aws_vpc.main.id
            cidr_block              = "10.0.${count.index}.0/24"
            availability_zone       = data.aws_availability_zones.available.names[count.index]
            map_public_ip_on_launch = true
            
            tags = {
              Name = "${{ inputs.project_name }}-${{ inputs.environment }}-public-${count.index + 1}"
            }
          }

          # Private Subnets
          resource "aws_subnet" "private" {
            count             = 2
            vpc_id            = aws_vpc.main.id
            cidr_block        = "10.0.${count.index + 10}.0/24"
            availability_zone = data.aws_availability_zones.available.names[count.index]
            
            tags = {
              Name = "${{ inputs.project_name }}-${{ inputs.environment }}-private-${count.index + 1}"
            }
          }

          # Internet Gateway
          resource "aws_internet_gateway" "main" {
            vpc_id = aws_vpc.main.id
            
            tags = {
              Name = "${{ inputs.project_name }}-${{ inputs.environment }}-igw"
            }
          }

          # Route Table for Public Subnets
          resource "aws_route_table" "public" {
            vpc_id = aws_vpc.main.id
            
            route {
              cidr_block = "0.0.0.0/0"
              gateway_id = aws_internet_gateway.main.id
            }
            
            tags = {
              Name = "${{ inputs.project_name }}-${{ inputs.environment }}-public-rt"
            }
          }

          # Route Table Associations
          resource "aws_route_table_association" "public" {
            count          = 2
            subnet_id      = aws_subnet.public[count.index].id
            route_table_id = aws_route_table.public.id
          }

          # Security Group
          resource "aws_security_group" "default" {
            name        = "${{ inputs.project_name }}-${{ inputs.environment }}-sg"
            description = "Default security group for ${{ inputs.project_name }}"
            vpc_id      = aws_vpc.main.id

            ingress {
              from_port   = 443
              to_port     = 443
              protocol    = "tcp"
              cidr_blocks = ["0.0.0.0/0"]
            }

            ingress {
              from_port   = 80
              to_port     = 80
              protocol    = "tcp"
              cidr_blocks = ["0.0.0.0/0"]
            }

            egress {
              from_port   = 0
              to_port     = 0
              protocol    = "-1"
              cidr_blocks = ["0.0.0.0/0"]
            }
            
            tags = {
              Name = "${{ inputs.project_name }}-${{ inputs.environment }}-sg"
            }
          }

          # Data sources
          data "aws_availability_zones" "available" {
            state = "available"
          }

          # Outputs
          output "vpc_id" {
            value       = aws_vpc.main.id
            description = "VPC ID"
          }

          output "public_subnet_ids" {
            value       = aws_subnet.public[*].id
            description = "Public subnet IDs"
          }

          output "private_subnet_ids" {
            value       = aws_subnet.private[*].id
            description = "Private subnet IDs"
          }

          output "security_group_id" {
            value       = aws_security_group.default.id
            description = "Default security group ID"
          }
          EOF
      
      - name: Terraform Init
        working-directory: ./terraform
        run: terraform init
      
      - name: Terraform Plan
        working-directory: ./terraform
        run: terraform plan -out=tfplan
      
      - name: Terraform Apply
        working-directory: ./terraform
        run: terraform apply -auto-approve tfplan
      
      - name: Display Outputs
        working-directory: ./terraform
        run: terraform output
